<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>NeverFall Editor</title>
    <style type="text/css">
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');

        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background: transparent;
            color: var(--text-primary);
            position: relative;
        }

        :root {
            --background-darkest: #0A0A0C;
            --background-dark: #111115;
            --background-primary: #18181D;
            --background-secondary: #222228;
            --border-color: #2A2A32;
            --text-primary: #E3E3E8;
            --text-secondary: #888899;
            --accent-primary: #E53935;
            --accent-secondary: #3EA6E0;
            --font-family: 'Inter', sans-serif;
        }

.tab-container {
    display: flex;
    align-items: flex-end; 
    background-color: var(--background-darkest);
    padding: 0 15px;
    border-bottom: 1px solid var(--border-color);
}

.tab {
    padding: 8px 12px;
    margin-right: 5px;
    display: flex;
    cursor: pointer;
    align-items: center; 
    border: 1px solid transparent;
    border-bottom: none;
    border-top-left-radius: 6px;
    border-top-right-radius: 6px;
    transition: all 0.2s ease;
    position: relative;
    color: var(--text-secondary);
}


        .tab.active {
            background-color: var(--background-dark);
            color: var(--text-primary);
            font-weight: 500;
            border-color: var(--border-color);
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 1px;
            background: var(--background-dark);
        }

        .tab:not(.active):hover {
            background-color: var(--background-primary);
        }

        .tab i.tab-icon {
            color: var(--accent-secondary);
            margin-right: 8px;
            font-size: 15px;
        }

        .tab .tab-name {
            padding-right: 15px;
            font-family: var(--font-family);
            font-size: 14px;
        }

        .tab .close-tab {
            font-size: 14px;
            color: var(--text-secondary);
            transition: color 0.2s, background-color 0.2s;
            border-radius: 50%;
            padding: 2px;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tab .close-tab:hover {
            background-color: #ffffff1a;
            color: var(--text-primary);
        }

        .tab:not(.active) .close-tab {
            opacity: 0;
            pointer-events: none;
        }

        .tab:hover .close-tab {
            opacity: 1;
            pointer-events: all;
        }

        .add-tab-btn {
            padding: 10px 12px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            margin-left: 5px;
            margin-top: 1px;
            align-self: flex-start;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .add-tab-btn:hover {
            background-color: var(--background-secondary);
            color: var(--text-primary);
        }

        .add-tab-btn i {
            font-size: 14px;
        }

        #container {
            position: absolute;
            top: 42px;
            bottom: 0;
            width: 100%;
            background: transparent;
            z-index: 5;
        }

        .monaco-editor {
            background: transparent !important;
            color: var(--text-primary) !important;
            font-family: 'SF Mono', 'Courier New', monospace !important;
            font-size: 14px !important;
        }

        .monaco-editor .margin {
            background: transparent !important;
            color: var(--text-secondary) !important;
            opacity: 0.6;
        }

        .monaco-editor .cursor {
            transition: left 0.1s ease, top 0.1s ease;
            animation: cursor-blink-pulse 1.2s infinite;
        }

        @keyframes cursor-blink-pulse {
            0%, 100% { opacity: 1; transform: scaleY(1); }
            50% { opacity: 0.6; transform: scaleY(1.2); }
        }

        .monaco-editor .token.keyword { color: #C586C0 !important; }
        .monaco-editor .token.string { color: #CE9178 !important; }
        .monaco-editor .token.number { color: #B5CEA8 !important; }
        .monaco-editor .token.comment { color: #6A9955 !important; font-style: italic; }
        .monaco-editor .token.identifier { color: #9CDCFE !important; }
        .monaco-editor .token.operator { color: #D4D4D4 !important; }
        .monaco-editor .token.predefined { color: #4FC1FF !important; }

        .notification-container {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 9999;
        }

        .notification {
            background: rgba(48, 48, 48, 0.96);
            color: #fff;
            padding: 6px 14px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(6px);
            transform: scale(0.95);
            opacity: 0;
        }

        .notification svg {
            width: 16px;
            height: 16px;
            fill: white;
        }

        #background-image {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            object-fit: cover;
            display: block;
        }

        #image-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(40, 40, 40, 0.98);
            padding: 30px;
            border-radius: 12px;
            z-index: 1000;
            display: none;
            color: #e0e0e0;
            font-family: 'Inter', sans-serif;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 300px;
        }

        #image-menu.show {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #image-menu h3 {
            margin: 0 0 20px;
            font-size: 1.5em;
            text-align: center;
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #image-menu label {
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 0.9em;
        }

        #image-menu input[type="file"] {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 6px;
            color: #ffffff;
        }

        #image-menu input[type="range"] {
            width: 100%;
            accent-color: #6699cc;
        }

        #image-menu button {
            background: linear-gradient(45deg, #6699cc, #557799);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            transition: transform 0.2s, background 0.3s;
        }

        #image-menu button:hover {
            background: linear-gradient(45deg, #557799, #446688);
        }

        #image-menu button:active {
            transform: translateY(0);
        }

        #image-menu #remove-image {
            background: linear-gradient(45deg, #cc6666, #994444);
        }

        #image-menu #remove-image:hover {
            background: linear-gradient(45deg, #994444, #773333);
        }
    </style>
</head>
<body>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <div class="tab-container" id="tabContainer">
        <div class="tab active" data-tab-id="tab1">
            <i class="fas fa-scroll tab-icon"></i>
            <span class="tab-name">Script.lua</span>
            <i class="fas fa-times close-tab"></i>
        </div>
        <button class="add-tab-btn" id="addTabBtn" title="New Tab">
            <i class="fas fa-plus"></i>
        </button>
    </div>
    <div id="container"></div>
    <img id="background-image" src="https://wallpapers.com/images/high/roblox-pictures-g9ouopdid48fz5ly.webp" />
    <div id="image-menu">
        <h3>Background Image Settings</h3>
        <label>
            Upload Image:
            <input type="file" id="image-upload" accept="image/*">
        </label>
        <label>
            Brightness:
            <input type="range" id="brightness-slider" min="0" max="2" step="0.1" value="1">
            <span id="brightness-value">1.0</span>
        </label>
        <button id="remove-image">Remove Background</button>
        <button id="close-menu">Close</button>
    </div>
    <div class="notification-container" id="notifContainer"></div>
    <script src="vs/loader.js"></script>
    <script type="text/javascript">
        Object.defineProperty(window, "localStorage", {
            value: {
                getItem: (k) => window.sessionStorage.getItem(k),
                setItem: (k, v) => window.sessionStorage.setItem(k, v),
                removeItem: (k) => window.sessionStorage.removeItem(k),
                clear: () => window.sessionStorage.clear()
            }
        });

        require.config({
            paths: {
                'vs': 'vs'
            }
        });

        var editor;
        var Proposals = [];
        var SetText;
        var ShowMinimap;
        var HideMinimap;
        var EnableAutoComplete;
        var DisableAutoComplete;
        var GetText;
        var AddIntellisense;
        var Refresh;
        var typingTimeout;
        var reloadTimeout;

        require(['vs/editor/editor.main'], function () {
            function getDependencyProposals() {
                return Proposals;
            }

            monaco.languages.registerCompletionItemProvider('lua', {
                provideCompletionItems: function (model, position) {
                    return getDependencyProposals();
                },
            });

            monaco.editor.defineTheme('net-theme-dark', {
                base: 'vs-dark',
                inherit: true,
                colors: {
                    "editor.background": "#00000000",
                    "editorLineNumber.foreground": "#5A5A5E",
                    "editor.selectionBackground": "#3d5a8a66",
                    "editor.inactiveSelectionBackground": "#3A3D4144",
                    "scrollbarSlider.background": "#FFFFFF22",
                    "scrollbarSlider.hoverBackground": "#FFFFFF33",
                    "scrollbarSlider.activeBackground": "#FFFFFF44"
                },
                rules: [
                    { token: 'global', foreground: '66CCFF', fontStyle: 'bold' },
                    { token: 'keyword', foreground: '569CD6', fontStyle: 'bold' },
                    { token: 'comment', foreground: '6A9955', fontStyle: 'italic' },
                    { token: 'number', foreground: 'B5CEA8' },
                    { token: 'string', foreground: 'CE9178' },
                    { token: 'method', foreground: 'FFA1DC' },
                    { token: 'identifier', foreground: '9CDCFE' },
                    { token: 'operator', foreground: 'D4D4D4' },
                ]
            });

            monaco.editor.setTheme('net-theme-dark');

            function updateProposals(suggestion) {
                Proposals = [{
                    label: suggestion,
                    kind: monaco.languages.CompletionItemKind.Text,
                    insertText: suggestion,
                    documentation: "AI-generated",
                    sortText: "0"
                }];
            }

            editor = monaco.editor.create(document.getElementById('container'), {
                language: 'lua',
                theme: "net-theme-dark",
                acceptSuggestionOnEnter: "smart",
                suggestOnTriggerCharacters: true,
                suggestSelection: "recentlyUsed",
                folding: true,
                wordBasedSuggestions: true,
                scrollbar: {
                    verticalHasArrows: true,
                },
                dragAndDrop: true,
                links: true,
                minimap: {
                    enabled: false,
                },
                showFoldingControls: "always",
                smoothScrolling: true,
            });

            let tabs = [];
            let activeTabId = 'tab1';
            const tabContainer = document.getElementById('tabContainer');
            const addTabBtn = document.getElementById('addTabBtn');

            function loadTabsFromLocalStorage() {
                const savedTabs = localStorage.getItem('editorTabs');
                if (savedTabs) {
                    tabs = JSON.parse(savedTabs);
                    if (!tabs.length) {
                        tabs = [{ id: 'tab1', name: 'Script.lua', content: '' }];
                    }
                } else {
                    tabs = [{ id: 'tab1', name: 'Script.lua', content: '' }];
                }
                renderTabs();
                switchTab(activeTabId);
            }

            function saveTabsToLocalStorage() {
                tabs = tabs.map(tab => ({
                    ...tab,
                    content: tab.id === activeTabId ? editor.getValue() : tab.content
                }));
                localStorage.setItem('editorTabs', JSON.stringify(tabs));
            }

            function renderTabs() {
                const tabsHtml = tabs.map(tab => `
                    <div class="tab ${tab.id === activeTabId ? 'active' : ''}" data-tab-id="${tab.id}">
                        <i class="fas fa-scroll tab-icon"></i>
                        <span class="tab-name">${tab.name}</span>
                        <i class="fas fa-times close-tab"></i>
                    </div>
                `).join('');
                tabContainer.innerHTML = tabsHtml + `
                    <button class="add-tab-btn" id="addTabBtn" title="New Tab">
                        <i class="fas fa-plus"></i>
                    </button>
                `;
                addTabBtnListener();
                addTabEventListeners();
            }

            function addTabEventListeners() {
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('close-tab')) {
                            switchTab(tab.dataset.tabId);
                        }
                    });
                    const closeBtn = tab.querySelector('.close-tab');
                    if (closeBtn) {
                        closeBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            closeTab(tab.dataset.tabId);
                        });
                    }
                });
            }

            function addTab() {
                const newTabId = `tab${Date.now()}`;
                const newTabName = `Script${tabs.length + 1}.lua`;
                tabs.push({ id: newTabId, name: newTabName, content: '' });
                switchTab(newTabId);
            }

            function switchTab(tabId) {
                const currentContent = editor.getValue();
                tabs = tabs.map(tab => ({
                    ...tab,
                    content: tab.id === activeTabId ? currentContent : tab.content
                }));
                activeTabId = tabId;
                const activeTab = tabs.find(tab => tab.id === tabId);
                editor.setValue(activeTab.content || '');
                renderTabs();
                saveTabsToLocalStorage();
            }

            function closeTab(tabId) {
                if (tabs.length === 1) {
                    createNotification("Cannot close the last tab");
                    return;
                }
                const tabIndex = tabs.findIndex(tab => tab.id === tabId);
                const tabName = tabs[tabIndex].name;
                tabs = tabs.filter(tab => tab.id !== tabId);
                if (activeTabId === tabId) {
                    activeTabId = tabs[tabIndex - 1]?.id || tabs[0].id;
                    switchTab(activeTabId);
                } else {
                    renderTabs();
                }
                saveTabsToLocalStorage();
            }

            function addTabBtnListener() {
                document.getElementById('addTabBtn').addEventListener('click', addTab);
            }

            function createNotification(text = "тест") {
                const container = document.getElementById("notifContainer");
                const notif = document.createElement("div");
                notif.className = "notification";
                notif.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zm0 13c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zm0-10a4 4 0 100 8 4 4 0 000-8z"/>
                    </svg>
                    <span>${text}</span>
                `;
                container.appendChild(notif);
                notif.animate([
                    { opacity: 0, transform: "scale(0.95)" },
                    { opacity: 1, transform: "scale(1)" }
                ], {
                    duration: 400,
                    easing: "ease",
                    fill: "forwards"
                });
                setTimeout(() => {
                    const hide = notif.animate([
                        { opacity: 1, transform: "scale(1)" },
                        { opacity: 0, transform: "scale(0.95)" }
                    ], {
                        duration: 400,
                        easing: "ease",
                        fill: "forwards"
                    });
                    hide.onfinish = () => notif.remove();
                }, 4000);
            }

            setTimeout(() => createNotification("Welcome to NeverFall! We wish you an enjoyable game"), 500);
            setTimeout(() => createNotification("Press Fn + Insert to open the background settings menu"), 1500);
            setTimeout(() => createNotification("All your settings and scripts are synchronized"), 2500);

            const backgroundImage = document.getElementById('background-image');
            const imageMenu = document.getElementById('image-menu');
            const imageUpload = document.getElementById('image-upload');
            const brightnessSlider = document.getElementById('brightness-slider');
            const brightnessValue = document.getElementById('brightness-value');
            const closeMenuButton = document.getElementById('close-menu');
            const removeImageButton = document.getElementById('remove-image');
            let isImageLoaded = true;

            function loadFromLocalStorage() {
                const savedImage = localStorage.getItem('backgroundImage');
                const savedBrightness = localStorage.getItem('backgroundBrightness') || '1';
                if (savedImage) {
                    backgroundImage.src = savedImage;
                    backgroundImage.style.filter = `brightness(${savedBrightness})`;
                    brightnessSlider.value = savedBrightness;
                    brightnessValue.textContent = savedBrightness;
                    isImageLoaded = true;
                } else {
    backgroundImage.src = '';
    backgroundImage.style.display = 'none';
    backgroundImage.style.filter = 'brightness(0)';
    brightnessSlider.value = 0;
    brightnessValue.textContent = '0.0';
    isImageLoaded = false;
}

                backgroundImage.style.display = 'block';
            }

            function saveToLocalStorage() {
                if (isImageLoaded && backgroundImage.src !== 'https://wallpapers.com/images/high/roblox-pictures-g9ouopdid48fz5ly.webp') {
                    localStorage.setItem('backgroundImage', backgroundImage.src);
                    localStorage.setItem('backgroundBrightness', brightnessSlider.value);
                } else if (!isImageLoaded) {
                    localStorage.removeItem('backgroundImage');
                    localStorage.removeItem('backgroundBrightness');
                }
            }

            function toggleImageMenu() {
                const isShown = imageMenu.classList.contains('show');
                imageMenu.classList.toggle('show');
                imageMenu.style.display = isShown ? 'none' : 'flex';
                editor.getDomNode().style.opacity = isShown ? '1' : '0.8';
            }

            imageUpload.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        backgroundImage.src = e.target.result;
                        backgroundImage.style.display = 'block';
                        backgroundImage.style.filter = `brightness(${brightnessSlider.value})`;
                        isImageLoaded = true;
                        saveToLocalStorage();
                    };
                    reader.readAsDataURL(file);
                }
            });

            brightnessSlider.addEventListener('input', () => {
                backgroundImage.style.filter = `brightness(${brightnessSlider.value})`;
                brightnessValue.textContent = brightnessSlider.value;
                saveToLocalStorage();
            });

            removeImageButton.addEventListener('click', () => {
    backgroundImage.src = '';
    backgroundImage.style.display = 'none';
    backgroundImage.style.filter = 'brightness(0)';
    brightnessSlider.value = 0;
    brightnessValue.textContent = '0.0';
    isImageLoaded = false;

    document.body.style.backgroundColor = "var(--background-darkest)";
    localStorage.removeItem('backgroundImage');
    localStorage.removeItem('backgroundBrightness');
    saveToLocalStorage();
});




            closeMenuButton.addEventListener('click', () => {
                toggleImageMenu();
            });

            editor.addCommand(monaco.KeyMod.Fn | monaco.KeyCode.Insert, () => {
                toggleImageMenu();
            });

            loadFromLocalStorage();
            loadTabsFromLocalStorage();

            EnableAutoComplete = function () {
                editor.updateOptions({
                    suggestOnTriggerCharacters: true,
                    acceptSuggestionOnEnter: "smart",
                    wordBasedSuggestions: true
                });
            }

            DisableAutoComplete = function () {
                editor.updateOptions({
                    suggestOnTriggerCharacters: false,
                    acceptSuggestionOnEnter: "off",
                    wordBasedSuggestions: false
                });
            }

            window.onresize = function () {
                editor.layout();
                backgroundImage.style.width = window.innerWidth + 'px';
                backgroundImage.style.height = window.innerHeight + 'px';
            };

            ShowMinimap = function () {
                editor.updateOptions({
                    minimap: {
                        enabled: true,
                    }
                });
            }

            HideMinimap = function () {
                editor.updateOptions({
                    minimap: {
                        enabled: false,
                    }
                });
            }

            let savedProposals = [];
            let restoreTimeout;

            async function fetchAICompletion() {
                const fullCode = GetText();
                const position = editor.getPosition();
                const query = `
You are a Roblox Lua AI code assistant. Your only task is to generate valid Lua code that should be inserted at the specified cursor position.
🎯 Objective:
- Insert missing code **at the exact cursor position** based on the full context.
- Your response must be **only** the code fragment that needs to be added. Nothing more.
🚫 Do NOT:
- Do not repeat any existing code.
- Do not include full functions or blocks unless the user just started one.
- Do not include quotes, triple backticks, formatting, or explanations.
- Do not return complete lines unless absolutely necessary.
✅ Do:
- Return the smallest valid Lua code needed to complete the line or expression.
- Ensure your response is **syntactically correct** and logically fits the context.
- In case of an empty function, print, or assignment, insert a realistic placeholder or expression.
📌 Example 1:
Code: print()
Cursor: Line 1, Column 7
→ Response: "Hello, World!"
📌 Example 2:
Code: local function a()
Cursor: Line 1, Column 21
→ Response: -- body
Now complete the code based on the cursor position:
${fullCode}
Cursor Line: ${position.lineNumber}, Column: ${position.column}
`;
                try {
                    const response = await fetch("https://api.mistral.ai/v1/chat/completions", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "Authorization": "Bearer pxiSYbaZy2MEnt1HoIiFmheGooBnsdES"
                        },
                        body: JSON.stringify({
                            model: "mistral-small",
                            messages: [
                                { role: "system", content: query },
                                { role: "user", content: query }
                            ],
                            temperature: 0.4,
                            top_p: 0.95,
                            max_tokens: 100
                        })
                    });
                    const data = await response.json();
                    const completionText = data.choices?.[0]?.message?.content?.trim();
                    if (completionText) {
                        savedProposals = Proposals.filter(item => item.detail !== "AI Suggestion");
                        Proposals = [];
                        AddIntellisense(completionText, "Text", "AI Suggestion", completionText);
                        editor.trigger('keyboard', 'editor.action.triggerSuggest', {});
                        clearTimeout(restoreTimeout);
                        restoreTimeout = setTimeout(() => {
                            Proposals = [...savedProposals];
                        }, 6000);
                    }
                } catch (error) {
                    console.error('Mistral API error:', error);
                }
            }

            editor.onDidChangeModelContent(function (e) {
                window.clearTimeout(typingTimeout);
                typingTimeout = setTimeout(fetchAICompletion, 6000);
                saveTabsToLocalStorage();
            });

            GetText = function () {
                return editor.getValue();
            }

            SetText = function (x) {
                editor.setValue(x);
            }

            AddIntellisense = function (l, k, d, i) {
                var t;
                switch (k) {
                    case "Class":
                        t = monaco.languages.CompletionItemKind.Class;
                        break;
                    case "Color":
                        t = monaco.languages.CompletionItemKind.Color;
                        break;
                    case "Constructor":
                        t = monaco.languages.CompletionItemKind.Constructor;
                        break;
                    case "Enum":
                        t = monaco.languages.CompletionItemKind.Enum;
                        break;
                    case "Field":
                        t = monaco.languages.CompletionItemKind.Field;
                        break;
                    case "File":
                        t = monaco.languages.CompletionItemKind.File;
                        break;
                    case "Folder":
                        t = monaco.languages.CompletionItemKind.Folder;
                        break;
                    case "Function":
                        t = monaco.languages.CompletionItemKind.Function;
                        break;
                    case "Interface":
                        t = monaco.languages.CompletionItemKind.Interface;
                        break;
                    case "Keyword":
                        t = monaco.languages.CompletionItemKind.Keyword;
                        break;
                    case "Method":
                        t = monaco.languages.CompletionItemKind.Method;
                        break;
                    case "Module":
                        t = monaco.languages.CompletionItemKind.Module;
                        break;
                    case "Property":
                        t = monaco.languages.CompletionItemKind.Property;
                        break;
                    case "Reference":
                        t = monaco.languages.CompletionItemKind.Reference;
                        break;
                    case "Snippet":
                        t = monaco.languages.CompletionItemKind.Snippet;
                        break;
                    case "Text":
                        t = monaco.languages.CompletionItemKind.Text;
                        break;
                    case "Unit":
                        t = monaco.languages.CompletionItemKind.Unit;
                        break;
                    case "Value":
                        t = monaco.languages.CompletionItemKind.Value;
                        break;
                    case "Variable":
                        t = monaco.languages.CompletionItemKind.Variable;
                        break;
                }
                Proposals.push({
                    label: l,
                    kind: t,
                    detail: d,
                    insertText: i
                });
            }

            async function load() {
                var docs = await (await fetch('https://raw.githubusercontent.com/iDevastate/Oxygen-v2/main/docs.txt')).json();
                for (var prop in docs) {
                    for (var item in docs[prop]) {
                        const document = docs[prop][item];
                        AddIntellisense(document.label, document.type, document.description, document.insert);
                    }
                }
                for (const Key of ["_G", "_VERSION", "Enum", "game", "plugin", "shared", "script", "workspace", "DebuggerManager", "elapsedTime", "LoadLibrary", "PluginManager", "settings", "tick", "time", "typeof", "UserSettings"])
                    AddIntellisense(Key, "Keyword", Key, Key);
                for (const Key of ["and", "break", "do", "else", "elseif", "end", "false", "for", "function", "if", "in", "local", "nil", "not", "or", "repeat", "return", "then", "true", "until", "while"])
                    AddIntellisense(Key, "Variable", Key, Key);
                for (const Key of ["math.abs", "math.acos", "math.asin", "math.atan", "math.atan2", "math.ceil", "math.cos", "math.cosh", "math.deg", "math.exp", "math.floor", "math.fmod", "math.frexp", "math.huge", "math.ldexp", "math.log", "math.max", "math.min", "math.modf", "math.pi", "math.pow", "math.rad", "math.random", "math.randomseed", "math.sin", "math.sinh", "math.sqrt", "math.tan", "math.tanh", "table.concat", "table.foreach", "table.foreachi", "table.sort", "table.insert", "table.remove", "Color3.new", "Instance.new", "BrickColor.new", "Vector3.new", "Vector2.new", "debug.gethook", "debug.getinfo", "debug.getlocal", "debug.getmetatable", "debug.getregistry", "debug.getupvalue", "debug.getuservalue", "debug.sethook", "debug.setlocal", "debug.setmetatable", "debug.setupvalue", "debug.setuservalue", "debug.traceback", "debug.upvalueid", "debug.upvaluejoin", "string.byte", "string.char", "string.dump", "string.find", "string.format", "string.gmatch", "string.gsub", "string.len", "string.lower", "string.match", "string.rep", "string.reverse", "string.sub", "string.upper", "coroutine.create", "coroutine.resume", "coroutine.running", "coroutine.status", "coroutine.wrap", "coroutine.yield"])
                    AddIntellisense(Key, "Method", Key, Key);
                for (const Key of ["Drawing", "debug", "Instance", "Color3", "Vector3", "Vector2", "BrickColor", "math", "table", "string", "coroutine", "Humanoid", "ClickDetector", "LocalScript", "Model", "ModuleScript", "Mouse", "Part", "Player", "Script", "Tool", "RunService", "UserInputService", "Workspace"])
                    AddIntellisense(Key, "Class", Key, Key);
                for (const Key of ["print", "warn", "wait", "info", "printidentity", "assert", "collectgarbage", "error", "getfenv", "getmetatable", "setmetatable", "ipairs", "loadfile", "loadstring", "newproxy", "next", "pairs", "pcall", "spawn", "rawequal", "rawget", "rawset", "select", "tonumber", "tostring", "type", "unpack", "xpcall", "delay", "stats", ":Remove()", ":BreakJoints()", ":GetChildren()", ":FindFirstChild()", ":FireServer()", ":InvokeServer()", ":ClearAllChildren()", ":Clone()", ":Destroy()", ":FindFirstAncestor()", ":FindFirstAncestorOfClass()", ":FindFirstAncestorWhichIsA()", ":FindFirstChildOfClass()", ":FindFirstChildWhichIsA()", ":GetDebugId()", ":GetDescendants()", ":GetFullName()", ":IsA()", ":GetPropertyChangedSignal()", ":IsAncestorOf()", ":IsDescendantOf()", ":WaitForChild()", ":Connect()", ":AncestryChanged()", ":Changed()", ":ChildAdded()", ":ChildRemoved()", ":DescendantAdded()", ":DescendantRemoving()", ":GetService()", ":GetObjects()", ":HttpGet()", ":Wait()"])
                    AddIntellisense(Key, "Function", Key, Key.includes(":") ? Key.substring(1, Key.length) : Key);
                for (const Key of ["Visible", "Color", "Transparency", "Thickness", "From", "To", "Text", "Size", "Center", "Outline", "OutlineColor", "Position", "TextBounds", "Font", "Data", "Rounding", "NumSides", "Radius", "Filled", "PointA", "PointB", "PointC", "PointD"])
                    AddIntellisense(Key, "Property", "Property for Drawing Library", Key);
            }

            load();

            Refresh = function () {
                var text = GetText();
                SetText('');
                editor.trigger('keyboard', 'type', {
                    text: text
                });
            }
        });
    </script>
</body>
</html>
